---
分类: [嵌入式]
标签: [算法]
知识共享许可协议: CC-BY-SA 4.0
备注: 本文首发于CSDN，原文：https://blog.csdn.net/qq_44884716/article/details/123926785
时间: 2022-04-02 18:45:44
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [题目来源](#题目来源)
- [题目内容](#题目内容)
- [分析](#分析)
- [我的程序](#我的程序)
- [运行结果](#运行结果)

<!-- /code_chunk_output -->



## 题目来源

浙大数据结构MOOC-PTA的课后题

## 题目内容

![](https://i-blog.csdnimg.cn/blog_migrate/b33313796b189830baee455d6d9f6f39.png)

## 分析

这个程序在课程里讲过，一共有四种方法，其中两种是同一种方法，只是进行了优化，这道题没有什么好分析的，直接写就行了。

## 我的程序

1. 暴力穷举：

   ```c
   #include <stdio.h>
   
   int main()
   {
       // 获取数据
       int size;
       scanf("%d", &size);
       int num[size];
       int max = 0, this = 0;
       for(int i = 0; i < size; i++)
       {
           scanf("%d", num + i);
       }
       // 穷举所有子列并找出最大和
       for(int i = 0; i < size; i++)	// 分别以每个项作为子列起点，然后计算这个起点所有子列和
       {
           this = 0;	// 每次计算完子列，都需要清空
           for(int j = i; j < size; j++)	// 计算当前所在起点的所有子列和
           {
               this += num[j];
               if(this > max)max = this;	// 当出现了更大的子列和时，将其存入max
           }
       }
       printf("%d", max);	// 打印出来
       return 0;
   }
   ```

   这种解法的时间复杂度为O(N^2^)，虽然能用但是还差点意思。

2. 分而治之：

   ```c
   #include <stdio.h>
   
   int getMaxSequenceSum(int* num, int size);
   
   int main()
   {
       int size;
       scanf("%d", &size);
       int num[size];
       int max = 0;
       for(int i = 0; i < size; i++)
       {
           scanf("%d", num + i);
       }
       max = getMaxSequenceSum(num, size);
       printf("%d", max);
       return 0;
   }
   
   int getMaxSequenceSum(int* num, int size) // 分而治之，左右分并分别计算最大子列和，然后从中间向两边延申计算最大子列和，比较三者，最终得到最大子列和
   {
       if(size == 1)
       {
           return num[0]>0?num[0]:0;  // 不可再分时，最大子列和就是本身或0（小于0的情况）
       }
       int left = getMaxSequenceSum(num, size / 2);
       int right = getMaxSequenceSum(num + size / 2, size - size / 2);
       int mid_l = 0, mid_r = 0;
       int max = 0, this = 0;
       for(int i = 1; i <= size / 2; i++)
       {
           this += num[size / 2 - i];
           if(mid_l < this)mid_l = this;
       }
       this = 0;
       for(int i = 0; i < size / 2; i++)
       {
           this += num[size / 2 + i];
           if(mid_r < this)mid_r = this;
       }
       max = mid_l + mid_r > left?mid_l + mid_r:left;
       return max > right?max:right;
   }
   ```

   这种解法的时间复杂度为O(NlogN)，已经是一种非常优秀的解法了。

3. 在线处理：

   ```c
   #include <stdio.h>
   
   int main()
   {
       // 获取数据
       int size;
       scanf("%d", &size);
       int num[size];
       int max = 0, this = 0;
       for(int i = 0; i < size; i++)
       {
           scanf("%d", num + i);
           this += num[i];
           if(this > max)max = this;
           else if(this < 0)this = 0;
       }
       printf("%d", max);	// 打印出来
       return 0;
   }
   ```

   在线处理的时间复杂度是O(N)，时间复杂度是线性的算法，是该问题的最优解。

## 运行结果

*下面的配图是我在MOOC中提交的图，里面代码没有优化，所以结果可能和预期有一点差别，不过整体大差没差。*

1.暴力穷举

![](https://i-blog.csdnimg.cn/blog_migrate/e7eac1179b6cb0d0857de2e2fb6d8008.png)

2.分而治之

![](https://i-blog.csdnimg.cn/blog_migrate/58fe4c0e624ac5d9b7d8622c0a6bb780.png)

3.在线处理

![](https://i-blog.csdnimg.cn/blog_migrate/94e73b4218a8e77ae0df4e31cf461637.png)